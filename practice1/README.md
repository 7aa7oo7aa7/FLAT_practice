
# mipt-flat-2020-practice1
# Пронякин Александр Александрович, Б05-922

16. Даны \alpha и слово u \in {a,b,c}*.
Найти длину самого длинного подслова u, являющегося также подсловом некоторого слова в L.

## Алгоритм:
Пусть n - длина слова u, m - длина регулярного выражения r;

Создадим структуру Matrix - двумерный массив размера (|u| + 1) x (|u| + 1),
элементы которого принимают значения true/false.
Две Matrix можно складывать за O(n^2).

Структура Result содержит текущую часть r (необязательно),
subword_indexes - Matrix индексов подслов u, которые можно задать подсловом r, 
full_indexes - Matrix индексов подслов u, которые можно задать r, 
prefix_indexes - Matrix индексов подслов u, которые можно задать префиксом r, 
suffix_indexes - Matrix индексов подслов u, которые можно задать суффиксом r.

Храним стек из Result, рассматриваем каждый символ регулярного выражения:  

### 1
Добавляем подслова (i, i) для всех i, таких что 0 <= i <= length, во все множества;

Асимптотика: O(n) - один проход по слову;

### a/b/c
Добавляем подслова (i, i + 1) для всех i, таких что word[i] = a/b/c соответственно, во все множества;

Асимптотика: O(n) - один проход по слову;

### *
Пусть x - предыдущий Result, y - текущий Result;

Добавляем подслова (i, i) для всех i, таких что 0 <= i <= length, во все множества;

Конкатенируем все подслова из x.suffix_indexes и y.prefix_indexes, пока это возможно, обновляем множества;

Достаём x из стека;

Асимптотика: O(n^3 log(n) + m) - три итерации по строке Matrix; итерации повторяются, пока можно добавить новые подслова, O(log(n)) раз (каждая итерация увеличивает длины подслов в >=2 раза); O(m) - добавление символа * в выражение;

### +
Достаём x, y из стека и добавляем в z (текущий Result) все подслова из x, y, с сохранением множеств, в которых они находились; 

Асимптотика: O(n^2 + m) - сложение Matrix; O(m) - составление нового выражения;

### .
Достаём x, y из стека и добавляем в z (текущий Result) все конкатенации подслов из x.suffix_indexes и y.prefix_indexes;

Копируем подслова x, y в подслова z, префиксы x в префиксы z, суффиксы y в суффиксы z;

Асимптотика: O(n^3 + m) - три итерации по строке Matrix; O(m) - составление нового выражения;

### Для всех символов
кладём в стек получившийся Result;

Асимптотика времени обработки одного символа: O(n^3 * log(n) + m) - максимум из всех предыдущих;

Проходим данным алгоритмом по всем символам регулярного выражения, ответ - максимум из (i.second - i.first) для всех i из stack.top().subword_indexes;
Если stack.top().subword_indexes оказался пустым, то ответ INF (нельзя разобрать никакое подслово u подсловом r) (пустое слово в алгоритме считается подсловом,
если в r присутствует 1 или *).

## Асимптотика
O(m * n^3 * log(n) + m^2) = (время обработки одного символа) * (количество символов в регулярном выражении). Можно не хранить в Result само выражение, 
тогда асимптотика будет O(m * n^3 * log(n)).

## Запуск
g++ -std=c++17 "name".cpp && ./a.out, где "name" - либо main (сама программа), либо test (тесты).
